<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>ZEROST&#x27;s Blog - ZEROST&#x27;s Blog</title><meta name="gridsome:hash" content="b9b0d2d686844970efabcd670d9359e5f92f1c5f"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="preconnect" href="https://fonts.googleapis.com"><link data-vue-tag="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding&amp;family=Noto+Sans+KR:wght@300;700&amp;display=swap"><link rel="preload" href="/assets/css/0.styles.58ed8584.css" as="style"><link rel="preload" href="/assets/js/app.bbf20190.js" as="script"><link rel="preload" href="/assets/js/page--src-pages-index-vue.6a75d322.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules-gridsome-app-pages-404-vue.d5e9f9b5.js"><link rel="prefetch" href="/assets/js/page--src-pages-about-vue.a56de421.js"><link rel="prefetch" href="/assets/js/page--src-templates-index-vue.ce9e5a22.js"><link rel="prefetch" href="/assets/js/page--src-templates-markdown-post-vue.691e115e.js"><link rel="stylesheet" href="/assets/css/0.styles.58ed8584.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div data-server-rendered="true" id="app" class="layout" data-v-32bcf3c6><header class="header"><strong><a href="/" aria-current="page" class="active--exact active"><h2>ZEROST's Blog</h2></a></strong><nav class="nav"><a href="/" aria-current="page" class="nav__link active--exact active">Home</a><a href="/about/" class="nav__link">About</a></nav></header><div class="main-container"><nav><ul><li><a href="/ko/posts/Blog">Blog</a><ul><li><a href="/ko/posts/Blog/%EB%B8%94%EB%A1%9C%EA%B7%B8%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80">블로그개발일지</a></li><li><a href="/ko/posts/Blog/%EC%97%90%EC%84%B8%EC%9D%B4">에세이</a></li></ul></li><li><a href="/ko/posts/Database">Database</a><ul><li><a href="/ko/posts/Database/Postgresql">Postgresql</a></li></ul></li><li><a href="/ko/posts/FrontEnd">FrontEnd</a><ul><li><a href="/ko/posts/FrontEnd/Gridsome">Gridsome</a></li><li><a href="/ko/posts/FrontEnd/Vue3">Vue3</a></li></ul></li><li><a href="/ko/posts/Java">Java</a><ul><li><a href="/ko/posts/Java/Library">Library</a></li></ul></li><li><a href="/ko/posts/Linux">Linux</a><ul><li><a href="/ko/posts/Linux/Shell-Script">Shell Script</a></li></ul></li><li><a href="/ko/posts/NodeJS">NodeJS</a><ul><li><a href="/ko/posts/NodeJS/%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD">개발환경</a></li></ul></li><li><a href="/ko/posts/Raspberry-Pi">Raspberry Pi</a><ul><li><a href="/ko/posts/Raspberry-Pi/Ubuntu-Linux">Ubuntu Linux</a></li></ul></li><li><a href="/ko/posts/TypeScript">TypeScript</a><!----></li></ul></nav><main><h2 class="subtitle" data-v-32bcf3c6>Zerost's Programming Notes</h2><div data-v-32bcf3c6><a href="/ko/posts/Java/Library/Apache-Commons-IO-라이브러리-FilenameUtils" data-v-32bcf3c6><h3 class="title" data-v-32bcf3c6>Apache Commons IO 라이브러리 FilenameUtils</h3></a><div class="post-info" data-v-32bcf3c6><div class="category" data-v-32bcf3c6>[카테고리] Java/Library</div><div class="date" data-v-32bcf3c6>[작성시간] 2022-06-28T22:29:00.000Z</div></div><div class="content" data-v-32bcf3c6>1. 배경
프로젝트를 수행하다보면 파일관련된 작업이 필요하다. 예를 들면 파일업로드, 첨부파일 다운로드등 처리를 하게 되면 파일명, 확장자, 파일사이즈, 경로등
처리가 필요하게 된다. 그 때마다 Java에서 지원하는 API를 찾아서, RAW데이터를 받아서 데이터 가공을 해야한다. 가공하는 과정에서 예기치 못하는 오류가 발생할 수 도 있다.
그래서 데이터 가공하는 과정도 별도로 테스트가 필요한 상황이 된다. 그런데, 이미 이런 기능들을 나만 사용하는 것도 아닐테고, 이미 한참전부터 많은 사람들이 사용하고 있었을 것 같고, 당연히 라이브러리도 있을 것이라고 판단했다. 검색을 했더니 Apache Commons IO 라는 라이브러리를 찾았다.
이번에는 파일의 확장자명을 가져오는 부분이 필요해서 해당 부분을 찾았다.
2. FileUtils Class 확인
File Utils class API를 확인하니 확장자를 가져오는 메소드가 존재한다.

static String getExtension(String fileName)

Gets the extension of a fileName.





파일명
리턴확장자명




foo.txt
&quot;txt&quot;


a/b/c.jpg
&quot;jpg&quot;


a/b.txt/c
&quot;&quot;


a/b/c
&quot;&quot;



예) 
System.out.println(FileUtils.getExtension(&quot;test.jpg&quot;));

jpg
3. 결론
이미 개발해놓은 라이브러리를 사용하는 것이 테스트코드를 줄일수 있는 방법중에 하나 일 것 같아서 적용해보았다. 내가 필요한 부분을 그리 어렵게 개발할 수도 있긴 하지만,
그 동안 많은 사람들이 사용하면서 많은 부분을 보완해가면서 만든 소스를 사용하는 것. 내가 예상하지 못했던 부분까지 생각해서 개발 되어 있을 수도 있으니 사용하는게 좋을 것 같다.
이런 기능을 개발할 시간에 해당 라이브러리를 적용하고 나는 좀 더 비지니스 개발에 집중하자.
9. 참조
FilenameUtils - Apache Commons IO
</div></div><div data-v-32bcf3c6><a href="/ko/posts/FrontEnd/Vue3/Vue3-script-setup" data-v-32bcf3c6><h3 class="title" data-v-32bcf3c6>Vue3 script setup</h3></a><div class="post-info" data-v-32bcf3c6><div class="category" data-v-32bcf3c6>[카테고리] FrontEnd/Vue3</div><div class="date" data-v-32bcf3c6>[작성시간] 2022-06-18T09:09:00.000Z</div></div><div class="content" data-v-32bcf3c6>1. &amp;#x3C;script setup&gt;란?
&amp;#x3C;script setup&gt;은 SFC(Single File Components)내에서 Composition API를 사용하기 위해서 권장되는 구문이다. &amp;#x3C;script&gt; 구문에 비해 몇가지 나은점을 제공한다.
공식사이트에는 아래와 같은 내용이 있다.

More succinct code with less boilerplate
Ability to declare props and emitted events using pure TypeScript
Better runtime performance (the template is compiled into a render function in the same scope, without an intermediate proxy)
Better IDE type-inference performance (less work for the language -server to extract types from code)

개인적으로 느낀바로는 변수나 객체등을 또 다시 return 구문에 입력하지 않아도 됨으로서, return 구문이 비대해지거나 return 기입시 오타등으로 인해서 예기치 않는 오류만 발생하지 않는 것 만으로도 매우 훌륭하다고 느낀다. 코드도 훨씬 깔끔해진다.
2. Composition API와 &amp;#x3C;script setup&gt; 비교
Composition API
&amp;lt;template&gt;
  &amp;lt;button @click=&quot;increment&quot;&gt;
    {{ state.count }}
  &amp;lt;/button&gt;
&amp;lt;/template&gt;

&amp;lt;script&gt;
import { reactive } from 'vue'

export default {
  setup() {
    const state = reactive({ count: 0 })

    function increment() {
      state.count++
    }

    // don't forget to expose the function as well.
    return {
      state,
      increment
    }
  }
}
&amp;lt;/script&gt;
&amp;#x3C;script setup&gt;
&amp;lt;script setup&gt;
import { reactive } from 'vue'

const state = reactive({ count: 0 })

function increment() {
  state.count++
}
&amp;lt;/script&gt;

&amp;lt;template&gt;
  &amp;lt;button @click=&quot;increment&quot;&gt;
    {{ state.count }}
  &amp;lt;/button&gt;
&amp;lt;/template&gt;
단순히 count만 증가시키는 모듈이지만 코드 라인수도 줄어들고, 간결하다. &amp;#x3C;script setup&gt;에서 선언한 변수나 함수를 return할 필요 없이 template에서 바로 사용할 수 있다. 변수가 한개 인데도 코드가 많이 줄어든다. 변수 갯수만큼 라인수가 늘어나는거라 복잡도가 높은 변수가 많은 프로그램일수록 소스가 간결해지는 효과는 좋다.
3. Using Components
컴포넌트 사용법. 컴포넌트 사용법도 정말 간단하다 단순하게 import만 해주게 되면 template에서 사용 할 수 있다. 기존 Composition API보다 간결하다.
&amp;lt;script setup&gt;
import MyComponent from './MyComponent.vue'
&amp;lt;/script&gt;

&amp;lt;template&gt;
  &amp;lt;MyComponent /&gt;
&amp;lt;/template&gt;
Dynamic Components
동적으로 조건에따라서 컴포넌트 사용
&amp;lt;script setup&gt;
import Foo from './Foo.vue'
import Bar from './Bar.vue'
&amp;lt;/script&gt;

&amp;lt;template&gt;
  &amp;lt;component :is=&quot;Foo&quot; /&gt;
  &amp;lt;component :is=&quot;someCondition ? Foo : Bar&quot; /&gt;
&amp;lt;/template&gt;
Recursive Components
컴포넌트 이름이 동일하거나 이름을 변경이 필요하다면 아래와 같이 사용할 수 있다.
import { FooBar as FooBarChild } from './components'
4. Top-level await
await 문법도 사용가능하다. 다만, Suspense와 함께 사용되어야 한다.
&amp;lt;script setup&gt;
const post = await fetch(`/api/post/1`).then((r) =&gt; r.json())
&amp;lt;/script&gt;
5. TypeScript 기능
타입 스크립트도 지원한다. 
Type-only props/emit declarations
const props = defineProps&amp;lt;{
  foo: string
  bar?: number
}&gt;()

const emit = defineEmits&amp;lt;{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}&gt;()
Default props values when using type declaration
interface Props {
  msg?: string
  labels?: string[]
}

const props = withDefaults(defineProps&amp;lt;Props&gt;(), {
  msg: 'hello',
  labels: () =&gt; ['one', 'two']
})
6. 마치며
Vue.js 3를 사용하고 있다면 무조건 적용해야 하는 것 같다. 토이프로젝트에  모듈들이 Composition API로 적용되어 있었다. &amp;#x3C;script setup&gt; 부분으로 하나씩 고쳐가고 있는데, 별도로 시간을 들여서 수정할만 하다. 소스가 간결해지는 부분이 참으로 만족스럽다. 
9. 참조

&amp;#x3C;script setup&gt; - Vue.js 공식사이트  
API styles - Vue.js 공식사이트

</div></div><div data-v-32bcf3c6><a href="/ko/posts/TypeScript/TypeScript-기본타입" data-v-32bcf3c6><h3 class="title" data-v-32bcf3c6>TypeScript 기본타입</h3></a><div class="post-info" data-v-32bcf3c6><div class="category" data-v-32bcf3c6>[카테고리] TypeScript</div><div class="date" data-v-32bcf3c6>[작성시간] 2022-06-06T14:42:00.000Z</div></div><div class="content" data-v-32bcf3c6>1. Primitives Type(윈시 타입)


string
기본적인 문자열. &quot;Hello, world&quot;와 같은 문자열
const msg: string = &quot;message&quot;;
let myName: string = &quot;Alice&quot;;


number
자바스크립트에는 int, float형이 있는데 두개를 구분하지 않고 심플하게 number로 사용
const size: number = 1234;
let size2: number = 1234;


boolean
true와 false 두가지 값이 있음
const isBig: boolean = true;
let isSmall: boolean = false;


변수 선언시(const, let) 타입을 표기를 안하게되면 컴파일러가 알아서 추론을 해서 선언하게 된다. 하지만 명시적으로 표기하는 것이 유지보수시에도 도움이 되고, 선언하지 않을꺼라면 굳이 타입스크립트를 사용하지 않고 Javascript를 사용해도 될 것 같다.
const msg = 'this is message'; //string 타입으로 추론 해줌(개인적으로 비추천함)
const count = 9; //number 타입으로 추론
2. Arrays(배열)
number형 배열 타입은 number[], string타입은 string[] 으로 선언하면 된다. Array\나 Array\ 으로 작성해도 된다.
const values: number[] = [1, 2, 3];
const values2: Array&amp;lt;number&gt; = [1, 2, 3];
3. Any
Any타입은 어떠한 값도 다 포함될 수 있는 값이다. Primitives Type이나 Array, 심지어 function까지 모두 다 들어갈수 있는 값이다. 이 타입은 굳이 사용하지 않은 것이 맞는 것 같다. 이걸 사용한다면 굳이 타입스크립트를 사용할 필요가 없는 것이다.
let value: any = { x: 0};
value = &quot;Hello&quot;; //오류 미발생
value = () =&gt; {}; //오류 미발생
value(); //오류 미발생
4. function (함수)
paramter와 return 타입에 설정가능하다.
function length(name: string): number {
  return name.length;
}

console.log(length(&quot;test&quot;)); //4 출력

length(1234); //Paramter타입오류 발생
const n: string = length('1234'); // Return타입 오류 발생
5. Enums
숫자 열거형(Numeric enums)
enum Direction {
  Up = 1,
  Down,
  Left,
  Right
}
  Up을 1로 선언했음. 그 이후에 선언되는 값은 1씩 증가한값이다. 그로 인해서 Down = 2, Left = 3, Right = 4가 된다.
enum Direction {
  Up,
  Down,
  Left,
  Right
} 
  아무런 값을 셋팅하지 않은 경우는 최상위부터 0으로 시작한다. Up = 0, Down = 1, Left = 2, Right = 3이 된다.
enum Direction {
  Up,  //0
  Down = 6, //6
  Left, //7
  Right //8
} 
  상위값부터 0으로 셋팅되고, Down = 6으로 셋팅을 할 경우, 그 다음부터 1씩 증가한다. Left = 7, Right = 8이 된다.
문자 열거형(String enums)
enum Direction {
  Up = &quot;UP&quot;,
  Down = &quot;DOWN&quot;,
  Left = &quot;LEFT&quot;,
  Right = &quot;RIGHT&quot;
}
이종 열거형(Heterogeneous enums)
enum BooleanLikeHeterogeneousEnum {
  No = 0,
  Yes = &quot;YES&quot;
}
  값을 숫자형과 문자형을 혼합해서 사용. 굳이 이렇게 사용할 필요는 없고, 권장하지 않는다고 함.
6. 마치며
TypeScript의 타입은 인터페이스, 함수타입, 클래스등 더 많은 타입이 있지만 기본타입에서는 여기까지만 정리하였다. 
9. 참조

Everyday Types - TypeScript 공식홈페이지
타입스크립트 시작하기 - 인프런

</div></div><div data-v-32bcf3c6><a href="/ko/posts/TypeScript/TypeScript개념과-설치" data-v-32bcf3c6><h3 class="title" data-v-32bcf3c6>TypeScript개념과 설치</h3></a><div class="post-info" data-v-32bcf3c6><div class="category" data-v-32bcf3c6>[카테고리] TypeScript</div><div class="date" data-v-32bcf3c6>[작성시간] 2022-05-29T10:33:00.000Z</div></div><div class="content" data-v-32bcf3c6>1. TypeScript란?
   타입스크립트(TypeScript)는 자바스크립트의 슈퍼셋인 오픈소스 프로그래밍 언어이다. 마이크로소프트에서 개발, 유지하고 있으며 엄격한 문법을 지원한다. 타입스크립트는 자바스크립트 엔진을 사용하면서 커다란 애플리케이션을 개발할 수 있게 설계된 언어이다. 타입스크립트에서 자신이 원하는 타입을 정의하고 프로그래밍을 하면 자바스크립트로 컴파일되어 실행할 수 있다.  
2. TypeScript vs JavaScript



분류
TypeScript
JavaScript




Data Type
Static Type
Dynamic Type


CompileTime/RunTime
CompileTime
Runtime


생산성↑
코드의 양이 많은 경우
코드의 양이 적은 경우


타입오류발생
컴파일
런타임


IDE 오류
잘못된 타입을 사용을 한 경우 .0오류 발생
오류 발생하지 않음


IDE 리팩토링
TYPE이 이미 정해져있기때문에 IDE에서 리팩토링 가능
IDE에서 지원하는 리팩토링은 불가(가능하더라도 정확하지 않음)



3. TypeScript 설치
npm을 설치한다. 기본적으로 nodejs는 설치되어있어야 한다. npm init -y 명령어 실행
$ npm init -y
Wrote to C:\workspace\typescript\package.json:

{
  &quot;name&quot;: &quot;typescript&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
package.json 파일이 생성되었다.
이제 TypeScript를 설치한다.
$ npm install typescript

added 1 package, and audited 2 packages in 2s

found 0 vulnerabilities
4. TypeScript 모듈 조회 사이트
type search - typescriptlang.org
예) react검색시 아래와같이 조회됨. @types..로 시작하는 모듈이 typescript로 개발된 패키지이다.
npm i react
npm i @types/react --save-dev
5. 마치며
  최근들어 Javascript로 개발된 framework의 문서들에도 타입스크립트의 내용이 점점 추가 되고 있고, 최근 개발된 framework의 소스를 확인해봐도 대부분 타입스크립트로 개발되어 있음을 알 수 있었다. 규모가 있는 프로그램을 개발하려고 한다면 Typescript는 이제 기본이 된듯하다.
6. 참조

타입스크립트 - 위키백과
[TypeScript] TypeScript 개념 및 사용하는 이유  
타입스크립트 시작하기 - 인프런

</div></div><div data-v-32bcf3c6><a href="/ko/posts/FrontEnd/Vue3/Vue-CLI-빌드시-public-폴더-하위-특정폴더-제외하기" data-v-32bcf3c6><h3 class="title" data-v-32bcf3c6>Vue CLI 빌드시 public 폴더 하위 특정폴더 제외하기</h3></a><div class="post-info" data-v-32bcf3c6><div class="category" data-v-32bcf3c6>[카테고리] FrontEnd/Vue3</div><div class="date" data-v-32bcf3c6>[작성시간] 2022-05-22T10:41:00.000Z</div></div><div class="content" data-v-32bcf3c6>배경
Vue.js CLI에서 빌드시 public 폴더중에 일부 폴더는 제외를 하고 싶었다. 이유는 해당 폴더는 파일업로드가 되는 폴더라서
굳이 빌드할때 copy가 될 필요는 없었다. 그래서 해당 방법을 한참 찾았다. 그리고는 결국 찾아내고 말았다.
환경
Vue CLI: 4.5.17
진행
vue.config.js 파일에 아래부분을 추가한다.
module.exports = {
  //...
  chainWebpack: config =&gt; {
    config.plugin('copy').tap(([options]) =&gt; {
      options[0].ignore.push('files/**')
      return [options]
    })
  }
  //...
}
결론
해당 files/** 에 해당하는 부분에 제외하고자 하는 폴더를 넣고 빌드하니 정상 제외된다.
</div></div></main></div></div>
    <script src="/assets/js/app.bbf20190.js" defer></script><script src="/assets/js/page--src-pages-index-vue.6a75d322.js" defer></script>
  </body>
</html>
